/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package io.firkin.kstreams.normalizer.errors.v1.avsc;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;

/** Example Model for errors like those that might arise from a Source Connector. Errors of this type will need to be mapped to a common schema. */
@org.apache.avro.specific.AvroGenerated
public class BaseError extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = -2850240063251767128L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"BaseError\",\"namespace\":\"io.firkin.kstreams.normalizer.errors.v1.avsc\",\"doc\":\"Example Model for errors like those that might arise from a Source Connector. Errors of this type will need to be mapped to a common schema.\",\"fields\":[{\"name\":\"timestamp\",\"type\":{\"type\":\"long\",\"logicalType\":\"local-timestamp-millis\"},\"doc\":\"The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.\"},{\"name\":\"correlation_id\",\"type\":{\"type\":\"string\",\"logicalType\":\"uuid\"},\"doc\":\"Unique id for event tracing\"},{\"name\":\"environment_id\",\"type\":[\"null\",\"string\"],\"doc\":\"Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.\",\"default\":null},{\"name\":\"application_id\",\"type\":[\"null\",\"string\"],\"doc\":\"Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.\",\"default\":null},{\"name\":\"instance_id\",\"type\":[\"null\",\"string\"],\"doc\":\"Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.\",\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  private static SpecificData MODEL$ = new SpecificData();
static {
    MODEL$.addLogicalTypeConversion(new org.apache.avro.data.TimeConversions.LocalTimestampMillisConversion());
  }

  private static final BinaryMessageEncoder<BaseError> ENCODER =
      new BinaryMessageEncoder<BaseError>(MODEL$, SCHEMA$);

  private static final BinaryMessageDecoder<BaseError> DECODER =
      new BinaryMessageDecoder<BaseError>(MODEL$, SCHEMA$);

  /**
   * Return the BinaryMessageEncoder instance used by this class.
   * @return the message encoder used by this class
   */
  public static BinaryMessageEncoder<BaseError> getEncoder() {
    return ENCODER;
  }

  /**
   * Return the BinaryMessageDecoder instance used by this class.
   * @return the message decoder used by this class
   */
  public static BinaryMessageDecoder<BaseError> getDecoder() {
    return DECODER;
  }

  /**
   * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
   * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
   * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
   */
  public static BinaryMessageDecoder<BaseError> createDecoder(SchemaStore resolver) {
    return new BinaryMessageDecoder<BaseError>(MODEL$, SCHEMA$, resolver);
  }

  /**
   * Serializes this BaseError to a ByteBuffer.
   * @return a buffer holding the serialized data for this instance
   * @throws java.io.IOException if this instance could not be serialized
   */
  public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
    return ENCODER.encode(this);
  }

  /**
   * Deserializes a BaseError from a ByteBuffer.
   * @param b a byte buffer holding serialized data for an instance of this class
   * @return a BaseError instance decoded from the given buffer
   * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
   */
  public static BaseError fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
    return DECODER.decode(b);
  }

  /** The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime. */
   private java.time.LocalDateTime timestamp;
  /** Unique id for event tracing */
   private java.lang.CharSequence correlation_id;
  /** Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to. */
   private java.lang.CharSequence environment_id;
  /** Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to. */
   private java.lang.CharSequence application_id;
  /** Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change. */
   private java.lang.CharSequence instance_id;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public BaseError() {}

  /**
   * All-args constructor.
   * @param timestamp The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
   * @param correlation_id Unique id for event tracing
   * @param environment_id Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
   * @param application_id Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
   * @param instance_id Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
   */
  public BaseError(java.time.LocalDateTime timestamp, java.lang.CharSequence correlation_id, java.lang.CharSequence environment_id, java.lang.CharSequence application_id, java.lang.CharSequence instance_id) {
    this.timestamp = timestamp;
    this.correlation_id = correlation_id;
    this.environment_id = environment_id;
    this.application_id = application_id;
    this.instance_id = instance_id;
  }

  public org.apache.avro.specific.SpecificData getSpecificData() { return MODEL$; }
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return timestamp;
    case 1: return correlation_id;
    case 2: return environment_id;
    case 3: return application_id;
    case 4: return instance_id;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  private static final org.apache.avro.Conversion<?>[] conversions =
      new org.apache.avro.Conversion<?>[] {
      new org.apache.avro.data.TimeConversions.LocalTimestampMillisConversion(),
      null,
      null,
      null,
      null,
      null
  };

  @Override
  public org.apache.avro.Conversion<?> getConversion(int field) {
    return conversions[field];
  }

  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: timestamp = (java.time.LocalDateTime)value$; break;
    case 1: correlation_id = (java.lang.CharSequence)value$; break;
    case 2: environment_id = (java.lang.CharSequence)value$; break;
    case 3: application_id = (java.lang.CharSequence)value$; break;
    case 4: instance_id = (java.lang.CharSequence)value$; break;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  /**
   * Gets the value of the 'timestamp' field.
   * @return The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
   */
  public java.time.LocalDateTime getTimestamp() {
    return timestamp;
  }


  /**
   * Sets the value of the 'timestamp' field.
   * The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
   * @param value the value to set.
   */
  public void setTimestamp(java.time.LocalDateTime value) {
    this.timestamp = value;
  }

  /**
   * Gets the value of the 'correlation_id' field.
   * @return Unique id for event tracing
   */
  public java.lang.CharSequence getCorrelationId() {
    return correlation_id;
  }


  /**
   * Sets the value of the 'correlation_id' field.
   * Unique id for event tracing
   * @param value the value to set.
   */
  public void setCorrelationId(java.lang.CharSequence value) {
    this.correlation_id = value;
  }

  /**
   * Gets the value of the 'environment_id' field.
   * @return Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
   */
  public java.lang.CharSequence getEnvironmentId() {
    return environment_id;
  }


  /**
   * Sets the value of the 'environment_id' field.
   * Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
   * @param value the value to set.
   */
  public void setEnvironmentId(java.lang.CharSequence value) {
    this.environment_id = value;
  }

  /**
   * Gets the value of the 'application_id' field.
   * @return Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
   */
  public java.lang.CharSequence getApplicationId() {
    return application_id;
  }


  /**
   * Sets the value of the 'application_id' field.
   * Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
   * @param value the value to set.
   */
  public void setApplicationId(java.lang.CharSequence value) {
    this.application_id = value;
  }

  /**
   * Gets the value of the 'instance_id' field.
   * @return Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
   */
  public java.lang.CharSequence getInstanceId() {
    return instance_id;
  }


  /**
   * Sets the value of the 'instance_id' field.
   * Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
   * @param value the value to set.
   */
  public void setInstanceId(java.lang.CharSequence value) {
    this.instance_id = value;
  }

  /**
   * Creates a new BaseError RecordBuilder.
   * @return A new BaseError RecordBuilder
   */
  public static io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder newBuilder() {
    return new io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder();
  }

  /**
   * Creates a new BaseError RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new BaseError RecordBuilder
   */
  public static io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder newBuilder(io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder other) {
    if (other == null) {
      return new io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder();
    } else {
      return new io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder(other);
    }
  }

  /**
   * Creates a new BaseError RecordBuilder by copying an existing BaseError instance.
   * @param other The existing instance to copy.
   * @return A new BaseError RecordBuilder
   */
  public static io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder newBuilder(io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError other) {
    if (other == null) {
      return new io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder();
    } else {
      return new io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder(other);
    }
  }

  /**
   * RecordBuilder for BaseError instances.
   */
  @org.apache.avro.specific.AvroGenerated
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<BaseError>
    implements org.apache.avro.data.RecordBuilder<BaseError> {

    /** The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime. */
    private java.time.LocalDateTime timestamp;
    /** Unique id for event tracing */
    private java.lang.CharSequence correlation_id;
    /** Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to. */
    private java.lang.CharSequence environment_id;
    /** Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to. */
    private java.lang.CharSequence application_id;
    /** Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change. */
    private java.lang.CharSequence instance_id;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.timestamp)) {
        this.timestamp = data().deepCopy(fields()[0].schema(), other.timestamp);
        fieldSetFlags()[0] = other.fieldSetFlags()[0];
      }
      if (isValidValue(fields()[1], other.correlation_id)) {
        this.correlation_id = data().deepCopy(fields()[1].schema(), other.correlation_id);
        fieldSetFlags()[1] = other.fieldSetFlags()[1];
      }
      if (isValidValue(fields()[2], other.environment_id)) {
        this.environment_id = data().deepCopy(fields()[2].schema(), other.environment_id);
        fieldSetFlags()[2] = other.fieldSetFlags()[2];
      }
      if (isValidValue(fields()[3], other.application_id)) {
        this.application_id = data().deepCopy(fields()[3].schema(), other.application_id);
        fieldSetFlags()[3] = other.fieldSetFlags()[3];
      }
      if (isValidValue(fields()[4], other.instance_id)) {
        this.instance_id = data().deepCopy(fields()[4].schema(), other.instance_id);
        fieldSetFlags()[4] = other.fieldSetFlags()[4];
      }
    }

    /**
     * Creates a Builder by copying an existing BaseError instance
     * @param other The existing instance to copy.
     */
    private Builder(io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError other) {
      super(SCHEMA$);
      if (isValidValue(fields()[0], other.timestamp)) {
        this.timestamp = data().deepCopy(fields()[0].schema(), other.timestamp);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.correlation_id)) {
        this.correlation_id = data().deepCopy(fields()[1].schema(), other.correlation_id);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.environment_id)) {
        this.environment_id = data().deepCopy(fields()[2].schema(), other.environment_id);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.application_id)) {
        this.application_id = data().deepCopy(fields()[3].schema(), other.application_id);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.instance_id)) {
        this.instance_id = data().deepCopy(fields()[4].schema(), other.instance_id);
        fieldSetFlags()[4] = true;
      }
    }

    /**
      * Gets the value of the 'timestamp' field.
      * The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
      * @return The value.
      */
    public java.time.LocalDateTime getTimestamp() {
      return timestamp;
    }


    /**
      * Sets the value of the 'timestamp' field.
      * The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
      * @param value The value of 'timestamp'.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder setTimestamp(java.time.LocalDateTime value) {
      validate(fields()[0], value);
      this.timestamp = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'timestamp' field has been set.
      * The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
      * @return True if the 'timestamp' field has been set, false otherwise.
      */
    public boolean hasTimestamp() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'timestamp' field.
      * The timestamp of when the error occurred, in Unix Epoch time on the error source system. In the NormalizedError, we want to track the wall-clock time as a UTC datetime.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder clearTimestamp() {
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'correlation_id' field.
      * Unique id for event tracing
      * @return The value.
      */
    public java.lang.CharSequence getCorrelationId() {
      return correlation_id;
    }


    /**
      * Sets the value of the 'correlation_id' field.
      * Unique id for event tracing
      * @param value The value of 'correlation_id'.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder setCorrelationId(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.correlation_id = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'correlation_id' field has been set.
      * Unique id for event tracing
      * @return True if the 'correlation_id' field has been set, false otherwise.
      */
    public boolean hasCorrelationId() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'correlation_id' field.
      * Unique id for event tracing
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder clearCorrelationId() {
      correlation_id = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'environment_id' field.
      * Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
      * @return The value.
      */
    public java.lang.CharSequence getEnvironmentId() {
      return environment_id;
    }


    /**
      * Sets the value of the 'environment_id' field.
      * Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
      * @param value The value of 'environment_id'.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder setEnvironmentId(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.environment_id = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'environment_id' field has been set.
      * Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
      * @return True if the 'environment_id' field has been set, false otherwise.
      */
    public boolean hasEnvironmentId() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'environment_id' field.
      * Environment where the error took place. In this object, the environment can be any string. In NormalizedError, there is an enum which needs to be mapped to.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder clearEnvironmentId() {
      environment_id = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'application_id' field.
      * Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
      * @return The value.
      */
    public java.lang.CharSequence getApplicationId() {
      return application_id;
    }


    /**
      * Sets the value of the 'application_id' field.
      * Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
      * @param value The value of 'application_id'.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder setApplicationId(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.application_id = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'application_id' field has been set.
      * Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
      * @return True if the 'application_id' field has been set, false otherwise.
      */
    public boolean hasApplicationId() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'application_id' field.
      * Application where the error took place. In this object, the application can be any string. In NormalizedError, there is an well known list of applications which it needs to be mapped to.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder clearApplicationId() {
      application_id = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'instance_id' field.
      * Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
      * @return The value.
      */
    public java.lang.CharSequence getInstanceId() {
      return instance_id;
    }


    /**
      * Sets the value of the 'instance_id' field.
      * Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
      * @param value The value of 'instance_id'.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder setInstanceId(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.instance_id = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'instance_id' field has been set.
      * Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
      * @return True if the 'instance_id' field has been set, false otherwise.
      */
    public boolean hasInstanceId() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'instance_id' field.
      * Instance where the error took place. In this object, the environment can be any string. In NormalizedError, there is no change.
      * @return This builder.
      */
    public io.firkin.kstreams.normalizer.errors.v1.avsc.BaseError.Builder clearInstanceId() {
      instance_id = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public BaseError build() {
      try {
        BaseError record = new BaseError();
        record.timestamp = fieldSetFlags()[0] ? this.timestamp : (java.time.LocalDateTime) defaultValue(fields()[0]);
        record.correlation_id = fieldSetFlags()[1] ? this.correlation_id : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.environment_id = fieldSetFlags()[2] ? this.environment_id : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.application_id = fieldSetFlags()[3] ? this.application_id : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.instance_id = fieldSetFlags()[4] ? this.instance_id : (java.lang.CharSequence) defaultValue(fields()[4]);
        return record;
      } catch (org.apache.avro.AvroMissingFieldException e) {
        throw e;
      } catch (java.lang.Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumWriter<BaseError>
    WRITER$ = (org.apache.avro.io.DatumWriter<BaseError>)MODEL$.createDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumReader<BaseError>
    READER$ = (org.apache.avro.io.DatumReader<BaseError>)MODEL$.createDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}










